---
title: "EECS151 Project"
layout: page
---

# Introduction

In this project, I was assigned to create a working processor as an ASIC using Verilog and Berkeley's technology called HAMMER.
We implemented 32 bit RISCV as the instruction set due to it being pipelined very well and it being very easy to prototype then use. 

# Overall Plan

- First come up with the schematic for our design
- Create the different modules: this includes the register files, the ALU, the immediate generator, and the memory.
- Define and create the bypassing and clear up any hazards
- Test amd simulate using HAMMER

- Second come up with a schematic for the direct mapped cache
- Define what happens in each cycle to an address coming in
- Test and simulate using HAMMER

# PART 1 Creating the CPU
# Creating the Modules

- First of all, we need to write the modules.

### Register files

- **Input:** 32 bit registers for reading rd1 and rd2, the write address and write data port, register write enable, reset, clk
- **Output:** the rd1 value, the rd2 value


**Algorithm**

- If we reset we need to put 0 in all of memory
- Because this will be a synchornous write, if the write is enabled on the positive edge of the clock we store the data to write at the specified address
- We cannot write to x0
- We then asynchronously assign the read to rd1 and rd2


````
module REGFILE_1W2R(d0, addr0, we0, q1, addr1, q2, addr2, clk, rst);

...


always @(posedge clk) begin
        // RISC-V style: reg0 is always 0
        if (rst) begin
            for (i = 0; i < DEPTH; i = i + 1) begin
                mem[i] <= 0;
            end
        end
        if (we0 == 1 && addr0 != 0)
            mem[addr0] <= d0;
    end

    assign q1 = mem[addr1];
    assign q2 = mem[addr2];


```` 

### Immediate Generator

- **Input:** the last 25 bits of the instruction, the immediate select
- **Output:** the immediate

**Algorithm**

- The whole thing is asynchronous, so output immediately reacts to input
- Based on the instruction, we generate some real number, look in the RISCV ISA for more details

````
module ImmGen (
	input [2:0] imm_sel,
	input [24:0] imm_in,
	output reg [31:0] imm_out
);

always @* begin
	case (imm_sel)
		`I:        imm_out = { {20{imm_in[24]}}, imm_in[24:13]};
		`S:        imm_out = { {20{imm_in[24]}}, imm_in[24:18], imm_in[4:0]};
		`SB:       imm_out = { {20{imm_in[24]}}, imm_in[0], imm_in[23:18], imm_in[4:1], 1'b0};
		`U:        imm_out = { imm_in[24:5], {12{1'b0}}};
		`UJ:       imm_out = { {12{imm_in[24]}}, imm_in[12:5], imm_in[13], imm_in[23:14], 1'b0};
		`CSR:      imm_out = { {15{1'b0}}, imm_in[12:8] , imm_in[24:13]};
		 default:  imm_out = 0;
	endcase
end 
````


### ALU
- **Input:** the rs1 value and the rs2 value, ALU select
- **Output:** the output of the selected operation on rs1 and rs2

**Algorithm**
- Mux all possible operations, then select which one the instruction in the pipeline is running

````
module ALU(
    input [31:0] A,B,
    input [3:0] ALUop,
    output reg [31:0] Out
);
    always @* begin
        case (ALUop)
	    `ALU_SUB    : Out = A - B;
	    `ALU_AND    : Out = A & B;
	    `ALU_OR     : Out = A | B;
    	    `ALU_XOR    : Out = A ^ B;
	    `ALU_SLT    : Out = $signed(A) < $signed(B);
	    `ALU_SLTU   : Out = A < B;
	    `ALU_SLL    : Out = A << B[4:0];
	    `ALU_SRA    : Out = $signed(A) >>> B[4:0];
	    `ALU_SRL    : Out = A >> B[4:0];
	    `ALU_COPY_B : Out = B;
	    `ALU_XXX    : Out = 32'b0; 
	    default     : Out = A + B;
        endcase
    end
````

### Memory Decode (Store Word and Load Word)
**Store Word Decode**
- **Input:** the selected memory address, the instruction, and the ALU output
- **Output:** the translated memory address

**Algorithm**
- Based on the store operation, we need to shift the data coming in and also which bits we need to write to
- For instance, if we are going to write a byte, but it's at the 1st index of the word, we would need to send the number 4'b0010 to the memory


**Load Word Decode**
- **Input:** the instruction and the data coming from the memory
- **Output:** the actual data to be sent back to the register files

**Algorithm**
- Like last time, the address for memory is addressed in 32 bit words, so the offset is omitted when returning the data. This is would mean that we have to shift
the data based on the instruction. 

````
module MemControl (
	input [31:0] store_in,
	input [31:0] store_addr,
	input [1:0] store_sel,
	output reg [31:0] store_out,
	input [31:0] mem_in,
	input [31:0] mem_addr,
	input [2:0] mem_sel,
	output reg [31:0] mem_out,
	output reg [3:0] MemWEn
);

always @(*) begin:
	
	# STORE WORD CASE #

	case (store_sel)
		SB: begin
			case (store_offset)
				# INSERT SHIFTING CODE HERE #
			endcase
		end 
		SH: begin
			case (store_offset)
				# INSERT SHIFTING CODE HERE #
			endcase
		end
		SW: begin
			store_out = store_in;
		end
	endcase


	# LOAD WORD CASE #

	case (mem_sel)
		LB: begin
			case(offset)
				# INSERT SHIFTING CODE HERE #
			endcase
		end
		LH: begin
			case(offset)
				# INSERT SHIFTING CODE HERE #
			endcase
		end
		LW: mem_out = mem_in;
		LBU: begin
                        case(offset)
                        	# INSERT SHIFTING CODE HERE #
			endcase
                end
		LHU: begin
                        case(offset)
                        	# INSERT SHIFTING CODE HERE #
			endcase
                end
	endcase
end

````

### Memory Module

- **Inputs:** valid/ready input for data and address coming in, 
- **Output:** valid/ready output for data coming out

**Algorithm**
- This is a tricky one to implement, essentially we would need to create a finite state machine with several states: reset state, the confirmed input state, and the write or read state
- If we reset then cancel the request through an invalid in the output
- If we have a valid request, then we would need to check whether to read or write, then do said action in the cycle
- Output the data



````
module no_cache_mem #(
  parameter CPU_WIDTH      = `CPU_INST_BITS,
  parameter WORD_ADDR_BITS = `CPU_ADDR_BITS - `ceilLog2(`CPU_INST_BITS/8)
) (
  input clk,
  input reset,

  input                       cpu_req_valid,
  output                      cpu_req_ready,
  input [WORD_ADDR_BITS-1:0]  cpu_req_addr,
  input [CPU_WIDTH-1:0]       cpu_req_data,
  input [3:0]                 cpu_req_write,

  output reg                  cpu_resp_valid,
  output reg [CPU_WIDTH-1:0]  cpu_resp_data
);

  localparam DEPTH = 2*1024*1024;
  localparam WORDS = `MEM_DATA_BITS/CPU_WIDTH;

  reg [`MEM_DATA_BITS-1:0] ram [DEPTH-1:0];

  wire [WORD_ADDR_BITS-`ceilLog2(WORDS)-1:0] upper_addr;
  assign upper_addr = cpu_req_addr[WORD_ADDR_BITS-1:`ceilLog2(WORDS)];

  wire [`ceilLog2(WORDS)-1:0] lower_addr;
  assign lower_addr = cpu_req_addr[`ceilLog2(WORDS)-1:0];

  wire [`MEM_DATA_BITS-1:0] read_data;
  assign read_data = (ram[upper_addr] >> CPU_WIDTH*lower_addr);

  assign cpu_req_ready = 1'b1;

  wire [CPU_WIDTH-1:0] wmask;
  assign wmask = {{8{cpu_req_write[3]}},
                  {8{cpu_req_write[2]}},
                  {8{cpu_req_write[1]}},
                  {8{cpu_req_write[0]}}};

  wire [`MEM_DATA_BITS-1:0] write_data;
  assign write_data = (ram[upper_addr] & ~({{`MEM_DATA_BITS-CPU_WIDTH{1'b0}},wmask} << CPU_WIDTH*lower_addr)) | ((cpu_req_data & wmask) << CPU_WIDTH*lower_addr);

  always @(posedge clk) begin
    if (reset) 
      cpu_resp_valid <= 1'b0;
    else if (cpu_req_valid && cpu_req_ready) begin
      if (cpu_req_write) begin
        cpu_resp_valid <= 1'b0;
        ram[upper_addr] <= write_data;
      end else begin
        cpu_resp_valid <= 1'b1;
        cpu_resp_data <= read_data[CPU_WIDTH-1:0];
      end
    end else
      cpu_resp_valid <= 1'b0;
  end

  initial
  begin : zero
    integer i;
    for (i = 0; i < DEPTH; i = i + 1)
      ram[i] = 0;
  end

endmodule
````



 









